#### high performance server program frame

服务器程序的一般架构原理可以分为3个模块：
1) io处理单元。
2) 逻辑单元。
3) 存储单元，一般是服务器程序的可选模块，内容与网络编程本身无关。

### 服务器模型
## C/S模型
TCP/IP协议在设计和实现上并没有客户端和服务端的概念，在通信过程中所有的机器都是对等。C/S模型的
逻辑很简单，服务器启动之后，首先创建一个(或者多个)监听socket，并调用bind函数将其绑定到服务器感兴趣的有名端口，然后调用listen函数等待客户连接，服务器稳定运行之后，客户端就阔以调用connect函数向服务器发起连接，由于客户端连接请求是一个异步的事件，服务器将使用某种i/o复用技术来进行监听(通
常是select系统调用)，当监听到连接请求之后，服务器就调用accept来接受它，并分配一个逻辑单元为新的连接服务。逻辑单元可以是新创建的子进程、子线程或者其他。以子进程为例。服务端将fork系统调用一个子进程，逻辑单元读取客户请求，处理该请求，然后将处理结果返回给客户端。客户端受到服务端的结果之后，可以继续向服务端发送请求，也可以主动关闭连接，则服务器执行被动关闭连接。
C/S模型非常使用资源相对集中的场合，并且它的实现也非常简单，但是缺点也非常明显，服务器是通信的中心，当访问量过大的时候，可能所有的客户都将得到很慢的响应。

## I/O模型
针对非阻塞的IO执行的系统调用可能因为无法立即完成而被系统挂起，知道等待的事件发生为止。比如，客户端通过connect调用想服务端发送连接，connect将首先发送syn给服务端，然后等待服务端返回ack，如果服务端的ack没有立即到达客户端，则connect调用将被挂起，直到客户端受到ack并唤醒connect调用，socket的基础api中，可能被阻塞的系统调用包括accept、send、connect等。

针对非阻塞的IO执行的系统调用则总是立即返回，而不管事件是否发生，如果事件没有立即发生，这些系统调用则返回-1，和出错的情况一样，我们必须根据errno来区分2种情况，对accept，send,recv而言，事件未发生errno通常设置为EAGAIN(意为再来一次)，或者EWOULDBLOCK(意为期望阻塞);对于connect而言，errno则设置为EINPROGRESS(意为在处理中)。

IO复用函数本身是阻塞的，它们能够提高程序效率的原因在于他们具有同时监听多个IO事件的能力。

SIGIO信号也可以用来报告IO事件，我们可以为一个目标文件描述符指定宿主进程，那么当指定的宿主进程将捕获到SIGIO信号。当目标文件描述符上有事件发生时，SIGIO信号的信号处理函数将被触发，我们也就阔以在该信号处理函数中执行非阻塞的IO操作。

从理论上说，阻塞IO、IO复用和信号驱动IO都是同步IO模型，因为在这三种IO模型中，IO的读写操作，都是在IO事件的发生的之后，由应用程序完成的。相反，而POSIX规范所定义的异步IO的读写操作则不同，对异步IO而言，用户可以直接对IO执行读写操作，这些IO操作告诉内核用户读写缓冲区的位置，以及IO完成之后内核通知应用程序的方式，异步IO的行为总是立即返回，而无论IO是否是阻塞的，因为真正的读写操作都是由内核完成的。也就是说，同步IO模型要求用户代码自行执行IO操作(将数据从内核缓冲区读入用户缓冲区，或者将数据从用户缓冲区写入内核缓冲区)，而异步IO机制则是有内核来执行IO操作，(数据在内核缓冲区和用户缓冲区之间的移动是由内核在后台完成的)。你可以这样认为。同步IO向用户程序通知的是IO就绪事件，而异步IO则是向应用程序通知的是IO完成的事件。

## 两种高效的事件处理模式

Reactor是这样的一种模式，它要求主线程只负责监听文件描述符上是否有事件发生，有的话则立即通知工作线程。除此之外，主线程不做任何其他实质性的工作，读写数据，接受新的连接，以及处理客户请求都在主线程中完成。
使用同步IO模型(epoll_wait)为例，实现的reactor模式的工作流程：
	1) 主线程网epoll内核时间表中注册socket的可读就绪事件。
	2) 主线程调用epoll_wait等待socket上有数据可读。
	3) 当socket有数据可读的时候，epoll_wait通知主线程，主线程则将socket可读事件放入请求队列。
	4)睡眠在请求队列上的某个工作线程被唤醒，它从socket上获取数据，并处理客户请求，然后向内核epoll事件表中注册可写的就绪事件。
	5)主线程调用epoll_wait等待socket可写。
	6)当socket可写时，epoll_wait通知主线程，主线程将socket可写事件放入请求队列。
	7)睡眠在请求队列上的某个工作线程被唤醒，它向socket上写入服务器处理客户请求的结果。

Proactor模式与Reactor模式不同，Proactor模式将所有的IO操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。利用异步IO模型(以aio_read和aio_write为例)实现的Proactor模式的工作流程是：
	1)主线程调用aio_read函数向内核注册socket上的可读事件，并告诉内核用户读取缓冲区的位置，以及读操作完成如何通知应用程序,(这里以信号为例)。
	2)主线程继续处理其他逻辑，
	3)当socket上的数据被读入用户缓冲区之后，内核向应用程序发送一个信号，以通知应用程序数据已经可读。
	4)应用程序预先定义好的signal handler函数选择一个一个工作线程来处理客户请求，工作线程处理完客户的请求之后，调用aio_write函数向内核注册socket上的可写时间，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序。
	5)主线程继续处理其他逻辑。
	6)当用户缓冲区的数据写入socket之后，内核将向应用程序发送一个信号，以通知应用程序已经发送完毕。
	7)应用程序预先定义好的signal handler选择一个工作线程来做善后处理，比如决定是否关闭socket.
注意：连接socket上的读写事件是通过aio_read/aio_write向内核注册的，因此内核将通过信号来向应用程序报告连接socket上的读写事件，所以主线程中epoll_wait调用仅仅用来检测socket上的连接请求事件，而不能用来检测连接socket的读写事件。

### 模拟proactor模式

利用同步IO方式模拟出Proactor模式的一种方法，其原理是：主线程执行数据的读写操作，读写完成之后，主线程向工作线程通知这一“完成事件”，那么从工作线程的角度来看，它们就获得了数据读写的结果，那么接下来只是对读写的结果进行逻辑处理。

使用同步IO模型(仍然是epoll_wait为例)模拟出Proactor模式的工作流程如下：
	1)主线程往epoll内核事件表中注册socket上的读就绪事件。
	2)主线程调用epoll_wait等待socket上有数据可读，
	3)当socket上有数据可读时，epoll_wait通知主线程，主线程从socket循环读取数据，直到没有更多的数据可读，然后将读取的数据封装成一个请求对象并插入请求队列。
	4)睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册socket上的写就绪事件。
	5)主线程调用epoll_wait等待socket可写。
	6)当socket可写的时候，epoll_wait通知主线程，主线程往socket上写入服务器处理客户端的请求的结果。

### 两种高效的并发模式
并发编程的目的是让程序“同时”执行多个任务，如果程序是计算密集型的，并发编程反而没有优势，因为线程间的切换导致了效率的降低，但是如果程序是计算密集型的，比如经常读写数据库、IO等，由于io的操作的速度远远没有cpu计算的速度快，所以让程序阻塞在io操作将浪费大量的时间，如果程序有多个执行线程，则当前被IO阻塞的执行线程可以主动放弃cpu(有操作系统调度)。并将执行转移到其他工作线程，这样，cpu就可以做更多有意义的事情。服务器主要有2种并发编程的模式，半同步/半异步和领导者/追随者模式。

### 半同步/半异步模式
在io模型中，同步和异步区分的是内核向应用程序通知的是何种io事件(是就绪事件还是完成事件)以及谁来完成io读写(是应用程序还是内核)。在并发模式中，同步指的是程序完全按照代码的序列的顺序执行，而异步指的是程序的执行需要由系统事件来驱动，常见的系统事件包括中断、信号等。
同步线程用于处理客户逻辑，异步线程用于处理io事件，异步线程监听到客户请求后，就将其封装称为请求对象并插入请求队列中，请求队列将通知某个工作在同步模式的工作线程来读取并处理该请求对象，具体选择哪个工作线程来为新的客户请求服务，则取决于请求队列的设计，比如最简单的轮流选取工作线程的round robin算法，也可以通过条件变量或者信号量的方法来随机的选择一个工作线程。

### 半同步/半反应堆模式
异步线程只有一个，由主线程来充当，它负责监听socket上的事件，如果监听socket上有可读事件，即有新的连接请求到来，主线程就接受之以得到新的连接socket，然后向epoll内核事件表中注册该socket上的读写事件，如果连接socket上有读写事件，即有新的客户请求到来或者有数据要发送到客户端，主线程就将该连接socket插入请求队列中，所有的工作线程都在请求队列中，当有任务到来时，他们通过竞争或者任务的接管权，这种竞争使得只有空闲的工作线程才有机会来处理新任务，这是很合理的。

主线程插入请求的队列的任务是就绪的连接socket，这说明半同步/半反应堆模式采用的事件处理模式是reactor模式，它要求工作线程自己从socket读取客户请求和往socket写入服务器应答。同时，我们可以使用proactor事件处理模式，即主线程来完成数据的读写，在这种情况下，主线程一般会将应用程序数据、任务类型等信息封装为一个任务对象，然后将其(或者是指向该任务对象的一个指针)插入请求队列，工作线程从请求队列中取得任务对象之后，既可直接处理，而无须执行读写操作。

同时，我们可以推理出这种模式的缺点：
	1)主线程和工作线程共享请求队列。主线程往请求队列中添加任务，或者工作线程从请求队列去除任务，都需要对请求队列加锁保护，从而白白耗费cpu时间。
	2)每个工作线程在同一时间只能处理一个客户请求，如果客户数量较多，而工作线程较少，则请求队列中将堆积很多任务对象，客户端的响应速度将愈来愈慢，如果通过增加工作线程来解决问题，则工作线程的切换也会耗费大量时间。
