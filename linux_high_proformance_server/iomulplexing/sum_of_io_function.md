### io复用函数的比较。

select poll epoll 三组系统调用都能同时监听多个文件描述符，它们将等待timeout参数指定的超时时间，
直到有一个或者多个文件描述符上有事件返回，返回值是文件描述符的数量，返回0表示没有事件发生。

1. select 的参数类型fd_set没有将文件描述符和事件绑定，仅仅是一个文件描述符的集合，这样导致了select不能处理更多类型的事件，另外以方面由于内核对fd_set集合的在线修改，应用程序下次调用select不得不重置3个fd_set集合。

2. poll的参数类型pollfd则多少聪明一些，它把文件描述符和事件都定义其中，任何事件都会被统一处理，
从而使得接口要简单的许多，并且内核每次修改是pollfd结构体的revents成员，而event成员保持不变，因此下次调用poll时无须重置Pollfd类型的事件参数，

由于每次select poll调用的是整个用户注册的事件集合（其中包含就绪和未就绪的），所以应用程序索引
就绪文件描述符的时间复杂度是O(n),epoll采用的是不同的方式来管理用户注册的事件，它在内核中维护一个事件表，并提供了一个独立的系统调用epoll_ctl来控制其中的添加、删除、修改事件，这样每次epoll_wait
调用都直接从该内核事件表中取得用户注册的事件，而无须反复从用户空间读入事件，同时，epoll_wait
系统调用的events参数用来返回就绪的事件，这使得应用程序索引就绪文件描述符的时间复杂度为O(1);

3. poll 和epoll_wait分别使用nfds和maxevents参数来指定最多的监听多少个文件描述符和事件。2个数值都
可以达到系统允许打开的文件描述符的数目。而select允许监听的最大文件描述符数量通常有限。

4. select poll都只能工作在相对低效的LT模式，而epoll可以工作在高效的ET模式，同时epoll还支持EPOLLONESHOT事件。可以进一步减少可读、可写、异常的事件。

5. 从实现的原理，select poll都是采用轮询的方式，每一次调用都要扫描整个注册文件描述符集合，并将其中就绪的文件描述符返回给用户程序，因此他们检测到就绪事件的算法的时间复杂度为O(n);
epoll_wait则不同，它采用的是回调机制，内核检测到就绪的文件描述符时，将会触发回调函数，回调函数将该文件描述符上的就绪事件插入内核就绪事件队列，内核最后在适当的时机将该就绪事件队列中的内容拷贝到
用户空间，因此epoll_wait无须轮询整个文件描述符集合来检测那些事件已经就绪，其时间复杂度为O(1),但是当连接比较多的，epoll的效率未必比select和epoll高，因为回调函数触发的比较频繁，所以epoll适合与连接数量多，但是活动连接比较少的情况。
