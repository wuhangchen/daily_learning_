## 一些必要的知识。

1. 多任务(multi-tasking)系统，操作系统接管了所有的硬件资源，并且本身运行在一个受硬件保护的级别，所有的应用程序都以进程(process)的方式运行在比宝座系统权限更低的级别，每个进程有自己的独立的地址空间，使得进程之间的地址空间相互隔离，cpu由操作系统统一进行分配，每一个进程根据进程的优先级都有机会得到cpu,但是，如果运行时间操过了一定的时间，操作系统会暂停该进程，将cpu资源分配给其他等待运行的进程，这种cpu的分配方式即所谓的抢占式(preemptive)，操作系统可以强制剥夺cpu资源并且分配给它认为目前最需要的进程，如果操作系统分配给每个进程的时间都很短，即cpu在多个进程间快速的切换，从而造成了很多进程在同时运行的假象。

2. 线程(thread)，称为轻量级进程(Lightweight process),是程序执行流的最小单元，一个标准的线程由线程id、当前指令指针(pc)、寄存器集合、栈组成，通常意义上，一个进程有多个线程组成，各个线程之间共享进程的内存空间(代码段、数据段、堆等)，即一些进程级别的资源(打开的文件和信号)。

3. 线程的访问级别非常自由，它可以访问进程内存空间中的所有数据，甚至包含其他线程中的堆栈，但是实际上线程也拥有自己的私有存储空间，
	- 栈
	- 线程的局部存储，是操作系统为线程单独提供的私有空间，通常为有限的空间。
	- 寄存器(包含pc指针)，寄存器是执行流的基本数据，因此为线程私有。
4. 在单cpu还是在多cpu的计算机上，线程总是“并发执行”，当线程数量小于等于处理器的数量时，这种并发是真正的并行状态，彼此互不相互打扰，但是在线程数量大于处理器数量的情况，线程的并发会受到一些阻碍，因此至少有一个处理器会运行多个线程。在单处理器上对应多线程的情况下，并发是一种模拟出来的状态，操作系统会让这样多线程轮流执行，每次仅执行一小段时间，这样每个线程看起来在同时进行，实际上是有线程的快速切换。在线程调度中，至少有三种状态：
	- 运行(running):线程正在运行
	- 就绪(ready):此时线程可以立刻执行，但是cpu已经被占用。
	- 等待(waiting):线程正在等待某一个事件的发生，无法执行。
5. 一般把频繁等待的线程称为io密集型线程(io bound thread),而把很少等待的线程称为cpu密集型线程(cpu bound thread)，io密集型线程总是更容易得到优先级的提升。在这样的情况下，线程可能会有一种饿死的状态(starvation)。

6. 可重入(reentrant)与线程安全，一个函数被重入，表示这个函数没有执行完成，由于外部因素或者内部调用，又一次进入该函数执行。一个函数要被重入，只有2种情况：
	- 多个线程同时执行这个函数
	- 函数自身调用自己。
一个函数可重入，表明该函数被重入之后不会产生任何不良后果。

7. 过度优化导致多线程的线程安全的问题，利用volatile关键字可以做到2件事情。
	- 阻止编译器为了提高速度将一个变量缓存到寄存器内而不返回。
	- 阻止编译器调整操作volatile变量的指令顺序。
